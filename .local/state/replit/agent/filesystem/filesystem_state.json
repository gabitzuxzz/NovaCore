{"file_contents":{"database/__init__.py":{"content":"","size_bytes":0},"ui/__init__.py":{"content":"","size_bytes":0},"bot.py":{"content":"import os\nimport sys\nimport logging\nimport asyncio\nfrom dotenv import load_dotenv\nimport discord\nfrom discord.ext import commands\nfrom pathlib import Path\nfrom ui.components import StockView\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('logs/novacore.log'),\n        logging.StreamHandler(sys.stdout)\n    ]\n)\n\nload_dotenv()\n\nREQUIRED_ENV_VARS = [\n    'DISCORD_TOKEN',\n    'MAIN_CHANNEL_ID',\n    'STAFF_CHANNEL_ID',\n    'PUBLIC_LOG_CHANNEL_ID',\n    'CUSTOMER_ROLE_ID',\n    'STAFF_ROLE_IDS',\n    'PAYPAL_EMAIL',\n    'DATABASE_PATH',\n    'LOG_DIR'\n]\n\nmissing_vars = [var for var in REQUIRED_ENV_VARS if not os.getenv(var)]\nif missing_vars:\n    logging.error(f\"Missing required environment variables: {', '.join(missing_vars)}\")\n    sys.exit(1)\n\nintents = discord.Intents.all()\nbot = commands.Bot(command_prefix='/', intents=intents)\n\nPath(os.getenv('LOG_DIR')).mkdir(parents=True, exist_ok=True)\nPath(os.path.dirname(os.getenv('DATABASE_PATH'))).mkdir(parents=True, exist_ok=True)\n\nasync def init_database():\n    \"\"\"Initialize database tables\"\"\"\n    from database.db_manager import DatabaseManager\n    db = DatabaseManager(os.getenv('DATABASE_PATH'))\n    await db.init_db()\n    logging.info('Database initialized successfully')\n\nasync def load_extensions():\n    \"\"\"Load all cog extensions\"\"\"\n    for filename in Path('./cogs').glob('*.py'):\n        if filename.stem != '__init__':\n            try:\n                await bot.load_extension(f'cogs.{filename.stem}')\n                logging.info(f'Loaded extension {filename.stem}')\n            except Exception as e:\n                logging.error(f'Failed to load extension {filename.stem}: {str(e)}')\n\n@bot.event\nasync def setup_hook():\n    \"\"\"Setup hook called before bot starts\"\"\"\n    await init_database()\n    await load_extensions()\n\n@bot.event\nasync def on_ready():\n    \"\"\"Handler for when bot is ready\"\"\"\n    logging.info(f'Logged in as {bot.user.name} ({bot.user.id})')\n    await bot.tree.sync()\n    \n    try:\n        channel = bot.get_channel(int(os.getenv('MAIN_CHANNEL_ID')))\n        if channel:\n            messages_to_delete = []\n            async for message in channel.history(limit=100):\n                if message.author == bot.user:\n                    messages_to_delete.append(message)\n            \n            for message in messages_to_delete:\n                try:\n                    await message.delete()\n                    logging.info(f'Deleted old stock message: {message.id}')\n                except Exception as e:\n                    logging.error(f'Failed to delete message {message.id}: {str(e)}')\n                \n            embed = discord.Embed(\n                title=\"üíº NovaCore Products\",\n                description=\"Welcome to our exclusive products catalog! Browse through our categories below to discover our premium offerings.\",\n                color=0x8b5cf6\n            )\n            embed.set_thumbnail(url=\"https://i.imgur.com/OpQROuS.png\")\n            embed.add_field(\n                name=\"üõí How to Purchase\",\n                value=\"1. Click `Show Stock`\\n2. Select a category\\n3. Choose your product\\n4. Complete checkout\",\n                inline=False\n            )\n            embed.set_footer(text=\"¬© NovaCore | Premium Digital Products\")\n            \n            view = StockView()\n            await channel.send(embed=embed, view=view)\n            logging.info('Stock panel posted successfully')\n    except Exception as e:\n        logging.error(f'Error setting up stock panel: {str(e)}')\n\n@bot.event\nasync def on_command_error(ctx, error):\n    if isinstance(error, commands.errors.CheckFailure):\n        await ctx.send(\"You don't have permission to use this command.\")\n    elif isinstance(error, commands.errors.CommandOnCooldown):\n        await ctx.send(f\"This command is on cooldown. Try again in {error.retry_after:.2f}s\")\n    else:\n        logging.error(f'Unhandled error: {str(error)}')\n        await ctx.send(\"An error occurred. Please try again later.\")\n\ndef main():\n    \"\"\"Main entry point for the bot\"\"\"\n    try:\n        bot.run(os.getenv('DISCORD_TOKEN'))\n    except Exception as e:\n        logging.critical(f'Fatal error: {str(e)}')\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()\n","size_bytes":4311},"__init__.py":{"content":"","size_bytes":0},"utils/helpers.py":{"content":"import asyncio\r\nimport os\r\nimport logging\r\nfrom typing import List, Optional, Dict\r\nimport aiosqlite\r\nfrom datetime import datetime\r\nimport aiofiles\r\nfrom pathlib import Path\r\n\r\nclass Validators:\r\n    @staticmethod\r\n    def validate_env_vars() -> List[str]:\r\n        \"\"\"\r\n        Validate required environment variables\r\n        Returns list of missing variables\r\n        \"\"\"\r\n        required_vars = [\r\n            'DISCORD_TOKEN',\r\n            'MAIN_CHANNEL_ID',\r\n            'STAFF_CHANNEL_ID',\r\n            'PUBLIC_LOG_CHANNEL_ID',\r\n            'CUSTOMER_ROLE_ID',\r\n            'STAFF_ROLE_IDS',\r\n            'PAYPAL_EMAIL',\r\n            'DATABASE_PATH',\r\n            'LOG_DIR'\r\n        ]\r\n        \r\n        optional_vars = [\r\n            'PRODUCT_CATEGORY_ID',\r\n            'BTC_ADDRESS',\r\n            'LTC_ADDRESS',\r\n            'USDT_ADDRESS',\r\n            'SOL_ADDRESS',\r\n            'ETH_ADDRESS'\r\n        ]\r\n        \r\n        missing = []\r\n        for var in required_vars:\r\n            if not os.getenv(var):\r\n                missing.append(var)\r\n                \r\n        return missing\r\n\r\nclass ImageManager:\r\n    @staticmethod\r\n    async def save_proof_image(order_id: str, image_url: str, log_dir: str) -> Optional[str]:\r\n        \"\"\"\r\n        Save proof image to disk\r\n        Returns saved file path or None if failed\r\n        \"\"\"\r\n        try:\r\n            # Create proof images directory if not exists\r\n            proof_dir = Path(log_dir) / \"proofs\"\r\n            proof_dir.mkdir(parents=True, exist_ok=True)\r\n            \r\n            # Generate filename with timestamp\r\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\r\n            filename = f\"{order_id}_{timestamp}.png\"\r\n            filepath = proof_dir / filename\r\n            \r\n            async with aiofiles.open(filepath, mode='wb') as f:\r\n                # Download and save image\r\n                # Implementation depends on how image_url is provided\r\n                # This is a placeholder\r\n                pass\r\n                \r\n            return str(filepath)\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error saving proof image: {str(e)}\")\r\n            return None\r\n\r\nclass DatabaseLock:\r\n    \"\"\"Simple async lock for database operations\"\"\"\r\n    def __init__(self):\r\n        self._locks = {}\r\n        \r\n    async def acquire(self, key: str):\r\n        \"\"\"Acquire lock for given key\"\"\"\r\n        while self._locks.get(key):\r\n            await asyncio.sleep(0.1)\r\n        self._locks[key] = True\r\n        \r\n    def release(self, key: str):\r\n        \"\"\"Release lock for given key\"\"\"\r\n        self._locks.pop(key, None)\r\n        \r\n    async def __aenter__(self):\r\n        return self\r\n        \r\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\r\n        pass\r\n\r\n# Global database lock instance\r\ndb_lock = DatabaseLock()","size_bytes":2856},"README.md":{"content":"# NovaCore Products Discord Bot\r\n\r\nA semi-automated shop system Discord bot for managing product sales, handling payments, and tracking orders.\r\n\r\n## Features\r\n\r\n- Product catalog with categories\r\n- Automated checkout flow\r\n- PayPal and Cryptocurrency payment support\r\n- Staff payment review system\r\n- Delivery system for digital products\r\n- Sales statistics and charts\r\n- Stock management\r\n- Role-based permissions\r\n\r\n## Requirements\r\n\r\n- Python 3.8 or higher\r\n- discord.py 2.3+\r\n- Additional packages listed in `requirements.txt`\r\n\r\n## Installation\r\n\r\n1. Clone the repository\r\n2. Create a virtual environment (recommended):\r\n```bash\r\npython -m venv venv\r\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\r\n```\r\n\r\n3. Install dependencies:\r\n```bash\r\npip install -r requirements.txt\r\n```\r\n\r\n4. Copy `.env.example` to `.env` and configure the environment variables:\r\n\r\n## Environment Variables\r\n\r\nRequired variables:\r\n- `DISCORD_TOKEN`: Your Discord bot token\r\n- `MAIN_CHANNEL_ID`: Channel ID for the stock panel\r\n- `STAFF_CHANNEL_ID`: Channel ID for staff payment review\r\n- `PUBLIC_LOG_CHANNEL_ID`: Channel ID for public purchase logs\r\n- `CUSTOMER_ROLE_ID`: Role ID for customers\r\n- `STAFF_ROLE_IDS`: Comma-separated role IDs for staff\r\n- `PAYPAL_EMAIL`: PayPal email for payments\r\n- `DATABASE_PATH`: Path to SQLite database file\r\n- `LOG_DIR`: Directory for logs and generated images\r\n\r\nOptional variables:\r\n- `PRODUCT_CATEGORY_ID`: Category for product channels\r\n- `BTC_ADDRESS`: Bitcoin wallet address\r\n- `LTC_ADDRESS`: Litecoin wallet address\r\n- `USDT_ADDRESS`: USDT wallet address (TRC20)\r\n- `SOL_ADDRESS`: Solana wallet address\r\n- `ETH_ADDRESS`: Ethereum wallet address\r\n\r\n## Usage\r\n\r\n1. Set up the environment variables\r\n2. Run the bot:\r\n```bash\r\npython bot.py\r\n```\r\n\r\n## Admin Commands\r\n\r\n- `/addstock` - Add or update a product\r\n- `/removestock` - Remove a product\r\n- `/setstock` - Set product stock amount\r\n- `/stats` - View sales statistics\r\n- `/listproducts` - List all products\r\n\r\n## Security Considerations\r\n\r\n- All sensitive data is stored in environment variables\r\n- Staff-only commands are protected by role checks\r\n- Database uses transactions to prevent race conditions\r\n- Payment proofs are reviewed manually by staff\r\n- Rate limits on admin commands\r\n\r\n## License\r\n\r\n¬© NovaCore - All Rights Reserved","size_bytes":2331},"cogs/product_management.py":{"content":"import discord\nfrom discord import app_commands\nfrom discord.ext import commands\nimport os\nimport logging\nfrom typing import Optional\nfrom database.db_manager import DatabaseManager\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nimport io\n\nclass ProductManagement(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.db = DatabaseManager(os.getenv('DATABASE_PATH'))\n        self._staff_role_ids = set(map(int, os.getenv('STAFF_ROLE_IDS').split(',')))\n        self._owner_role_id = int(os.getenv('OWNER_ROLE_ID'))\n\n    def is_staff(self, member: discord.Member) -> bool:\n        \"\"\"Check if member has staff role\"\"\"\n        return any(role.id in self._staff_role_ids for role in member.roles) or \\\n               member.guild_permissions.administrator\n\n    def is_owner(self, member: discord.Member) -> bool:\n        \"\"\"Check if member has owner role\"\"\"\n        return self._owner_role_id in [r.id for r in member.roles] or \\\n               member.guild.owner_id == member.id\n\n    @app_commands.command(name=\"addproduct\")\n    @app_commands.describe(\n        category=\"Product category\",\n        product=\"Product name\",\n        price=\"Product price in EUR\",\n        description=\"Product description\",\n        deliverables=\"Comma-separated deliverables or file URL\",\n        image_url=\"Product image URL\",\n        stock=\"Initial stock amount\"\n    )\n    @commands.cooldown(1, 30, commands.BucketType.user)\n    async def addproduct(self, interaction: discord.Interaction, category: str,\n                        product: str, price: float, description: str,\n                        deliverables: str, image_url: str, stock: int = 0):\n        \"\"\"Add or update a product in stock\"\"\"\n        if not self.is_owner(interaction.user):\n            await interaction.response.send_message(\n                \"You don't have permission to use this command.\",\n                ephemeral=True\n            )\n            return\n\n        valid_categories = [\"best_sold\", \"new\", \"social\", \"discord\", \"accounts\", \"services\"]\n        if category.lower() not in valid_categories:\n            categories_str = \", \".join(valid_categories)\n            await interaction.response.send_message(\n                f\"Invalid category. Please use one of: {categories_str}\",\n                ephemeral=True\n            )\n            return\n\n        if price <= 0:\n            await interaction.response.send_message(\n                \"Price must be greater than 0.\",\n                ephemeral=True\n            )\n            return\n\n        success = await self.db.add_product(\n            product, category, price, description,\n            image_url, deliverables, stock\n        )\n\n        if success:\n            embed = discord.Embed(\n                title=\"‚úÖ Product Added Successfully\",\n                description=f\"**{product}** has been added to the store!\",\n                color=0x00ff00\n            )\n            if image_url and image_url.startswith(('http://', 'https://')):\n                embed.set_thumbnail(url=image_url)\n            embed.add_field(name=\"üìÅ Category\", value=f\"`{category.title()}`\", inline=True)\n            embed.add_field(name=\"üí∞ Price\", value=f\"**‚Ç¨{price:.2f}**\", inline=True)\n            embed.add_field(name=\"üì¶ Stock\", value=f\"`{stock}` units\", inline=True)\n            embed.add_field(name=\"üìù Description\", value=description, inline=False)\n            embed.add_field(name=\"üéÅ Deliverables\", value=deliverables, inline=False)\n            embed.set_footer(text=f\"Added by {interaction.user.name}\", icon_url=interaction.user.display_avatar.url)\n            embed.timestamp = discord.utils.utcnow()\n            await interaction.response.send_message(embed=embed)\n        else:\n            await interaction.response.send_message(\n                \"Failed to add/update product. Please try again.\",\n                ephemeral=True\n            )\n\n    @app_commands.command(name=\"removestock\")\n    @app_commands.describe(product=\"Product name to remove\")\n    @commands.cooldown(1, 30, commands.BucketType.user)\n    async def removestock(self, interaction: discord.Interaction, product: str):\n        \"\"\"Remove a product from stock\"\"\"\n        if not self.is_owner(interaction.user):\n            await interaction.response.send_message(\n                \"You don't have permission to use this command.\",\n                ephemeral=True\n            )\n            return\n\n        success = await self.db.remove_product(product)\n        if success:\n            await interaction.response.send_message(\n                f\"‚úÖ Successfully removed {product} from stock.\"\n            )\n        else:\n            await interaction.response.send_message(\n                f\"Failed to remove {product}. Please try again.\",\n                ephemeral=True\n            )\n\n    @app_commands.command(name=\"setstock\")\n    @app_commands.describe(\n        product=\"Product name\",\n        amount=\"New stock amount\"\n    )\n    @commands.cooldown(1, 30, commands.BucketType.user)\n    async def setstock(self, interaction: discord.Interaction,\n                      product: str, amount: int):\n        \"\"\"Set stock amount for a product\"\"\"\n        if not self.is_staff(interaction.user):\n            await interaction.response.send_message(\n                \"You don't have permission to use this command.\",\n                ephemeral=True\n            )\n            return\n\n        if amount < 0:\n            await interaction.response.send_message(\n                \"Stock amount cannot be negative.\",\n                ephemeral=True\n            )\n            return\n\n        success = await self.db.update_stock(product, amount)\n        if success:\n            await interaction.response.send_message(\n                f\"‚úÖ Updated stock for {product} to {amount}\"\n            )\n        else:\n            await interaction.response.send_message(\n                f\"Failed to update stock for {product}. Please try again.\",\n                ephemeral=True\n            )\n\n    @app_commands.command(name=\"stats\")\n    @app_commands.describe(\n        period=\"Statistics period (daily/weekly/monthly/all)\"\n    )\n    @app_commands.choices(period=[\n        app_commands.Choice(name=\"Daily\", value=\"daily\"),\n        app_commands.Choice(name=\"Weekly\", value=\"weekly\"),\n        app_commands.Choice(name=\"Monthly\", value=\"monthly\"),\n        app_commands.Choice(name=\"All Time\", value=\"all\")\n    ])\n    async def stats(self, interaction: discord.Interaction,\n                   period: str = \"all\"):\n        \"\"\"View sales statistics\"\"\"\n        if not self.is_staff(interaction.user):\n            await interaction.response.send_message(\n                \"You don't have permission to use this command.\",\n                ephemeral=True\n            )\n            return\n\n        await interaction.response.defer()\n\n        try:\n            summary, best_sellers = await self.db.get_sales_stats(period)\n\n            # Create matplotlib chart\n            plt.figure(figsize=(10, 6))\n            plt.style.use('dark_background')\n            \n            dates = [b['date'] for b in best_sellers]\n            revenues = [b['revenue'] for b in best_sellers]\n            \n            plt.plot(dates, revenues, marker='o', color='#8b5cf6')\n            plt.title(f'Revenue Over Time ({period.title()})')\n            plt.xlabel('Date')\n            plt.ylabel('Revenue (‚Ç¨)')\n            plt.grid(True, alpha=0.3)\n            \n            # Rotate x-axis labels for better readability\n            plt.xticks(rotation=45)\n            \n            # Save chart\n            chart_path = os.path.join(\n                os.getenv('LOG_DIR'),\n                f'stats_{period}_{datetime.now().strftime(\"%Y%m%d_%H%M%S\")}.png'\n            )\n            plt.savefig(chart_path, bbox_inches='tight', dpi=300)\n            plt.close()\n\n            # Create embed\n            embed = discord.Embed(\n                title=f\"üìä Sales Statistics ({period.title()})\",\n                color=0x8b5cf6\n            )\n            \n            embed.add_field(\n                name=\"Summary\",\n                value=f\"\"\"\n                Total Orders: {summary['total_orders']}\n                Completed Orders: {summary['completed_orders']}\n                Total Revenue: ‚Ç¨{summary['total_revenue']:.2f}\n                \"\"\",\n                inline=False\n            )\n\n            if best_sellers:\n                best_products = \"\\n\".join(\n                    f\"‚Ä¢ {b['name']}: {b['units_sold']} sold, ‚Ç¨{b['revenue']:.2f}\"\n                    for b in best_sellers[:5]\n                )\n                embed.add_field(\n                    name=\"Best Selling Products\",\n                    value=best_products or \"No sales data\",\n                    inline=False\n                )\n\n            # Attach chart\n            file = discord.File(chart_path, filename=\"stats_chart.png\")\n            embed.set_image(url=\"attachment://stats_chart.png\")\n\n            await interaction.followup.send(\n                embed=embed,\n                file=file\n            )\n\n        except Exception as e:\n            logging.error(f\"Error generating stats: {str(e)}\")\n            await interaction.followup.send(\n                \"Failed to generate statistics. Please try again.\",\n                ephemeral=True\n            )\n\n    @app_commands.command(name=\"listproducts\")\n    @app_commands.describe(category=\"Optional category filter\")\n    async def listproducts(self, interaction: discord.Interaction,\n                          category: Optional[str] = None):\n        \"\"\"List all products or products in a category\"\"\"\n        if not self.is_staff(interaction.user):\n            await interaction.response.send_message(\n                \"You don't have permission to use this command.\",\n                ephemeral=True\n            )\n            return\n\n        products = await self.db.get_products_by_category(category) if category \\\n                  else await self.db.get_all_products()\n\n        if not products:\n            await interaction.response.send_message(\n                f\"No products found{f' in category {category}' if category else ''}.\",\n                ephemeral=True\n            )\n            return\n\n        embed = discord.Embed(\n            title=f\"üì¶ Product List{f' - {category}' if category else ''}\",\n            color=0x8b5cf6\n        )\n\n        for product in products:\n            embed.add_field(\n                name=product['name'],\n                value=f\"\"\"\n                Category: {product['category']}\n                Price: ‚Ç¨{product['price']:.2f}\n                Stock: {product['stock']}\n                \"\"\",\n                inline=True\n            )\n\n        await interaction.response.send_message(embed=embed)\n\n    @app_commands.command(name=\"vouch\")\n    @app_commands.describe(\n        stars=\"Rating stars (1-5)\",\n        description=\"Vouch description\",\n        proof=\"Optional proof link (image/screenshot)\"\n    )\n    @commands.cooldown(1, 60, commands.BucketType.user)\n    async def vouch(self, interaction: discord.Interaction, stars: int,\n                   description: str, proof: Optional[str] = None):\n        \"\"\"Submit a vouch/review for the server\"\"\"\n        if stars < 1 or stars > 5:\n            await interaction.response.send_message(\n                \"Stars must be between 1 and 5.\",\n                ephemeral=True\n            )\n            return\n\n        star_display = \"‚≠ê\" * stars + \"‚òÜ\" * (5 - stars)\n        \n        embed = discord.Embed(\n            title=\"‚ú® New Vouch Received!\",\n            description=description,\n            color=0xFFD700 if stars >= 4 else 0x8b5cf6\n        )\n        \n        embed.add_field(name=\"Rating\", value=star_display, inline=False)\n        embed.set_author(\n            name=f\"{interaction.user.name}#{interaction.user.discriminator}\",\n            icon_url=interaction.user.display_avatar.url\n        )\n        \n        if proof:\n            if proof.startswith('http'):\n                embed.set_image(url=proof)\n            else:\n                embed.add_field(name=\"Proof\", value=proof, inline=False)\n        \n        embed.set_footer(text=f\"User ID: {interaction.user.id}\")\n        embed.timestamp = discord.utils.utcnow()\n\n        vouch_channel_id = os.getenv('VOUCH_CHANNEL_ID')\n        if vouch_channel_id:\n            vouch_channel = interaction.guild.get_channel(int(vouch_channel_id))\n            if vouch_channel:\n                await vouch_channel.send(embed=embed)\n        \n        await interaction.response.send_message(\n            \"‚úÖ Thank you for your vouch! It has been submitted successfully.\",\n            ephemeral=True\n        )\n\nasync def setup(bot):\n    await bot.add_cog(ProductManagement(bot))\n","size_bytes":12701},"ui/components.py":{"content":"import discord\nfrom discord import ui\nfrom typing import Optional, List\nimport logging\nimport os\n\nclass CategorySelect(ui.Select):\n    def __init__(self):\n        options = [\n            discord.SelectOption(value=\"best_sold\", label=\"Best Sold\", emoji=\"üèÜ\"),\n            discord.SelectOption(value=\"new\", label=\"New\", emoji=\"‚ú®\"),\n            discord.SelectOption(value=\"social\", label=\"Social Media Boost\", emoji=\"üì±\"),\n            discord.SelectOption(value=\"discord\", label=\"Discord\", emoji=\"üí¨\"),\n            discord.SelectOption(value=\"accounts\", label=\"Accounts\", emoji=\"üë§\"),\n            discord.SelectOption(value=\"services\", label=\"Services\", emoji=\"üõ†Ô∏è\")\n        ]\n        super().__init__(\n            placeholder=\"Select a category...\",\n            min_values=1,\n            max_values=1,\n            options=options\n        )\n\n    async def callback(self, interaction: discord.Interaction):\n        await interaction.response.defer(ephemeral=True)\n        \n        from database.db_manager import DatabaseManager\n        \n        db = DatabaseManager(os.getenv('DATABASE_PATH'))\n        products = await db.get_products_by_category(self.values[0])\n        if not products:\n            await interaction.followup.send(\"‚ùå No products available in this category.\", ephemeral=True)\n            return\n        \n        embed = discord.Embed(\n            title=f\"üõçÔ∏è {self.values[0].replace('_', ' ').title()} Products\",\n            description=\"Browse our premium selection below. Click the **Buy** button to purchase.\",\n            color=0x8b5cf6\n        )\n        \n        for product in products:\n            status = \"üü¢ In Stock\" if product['stock'] > 0 else \"üî¥ Out of Stock\"\n            embed.add_field(\n                name=f\"**{product['name']}** - ‚Ç¨{product['price']:.2f}\",\n                value=f\"{product['description'][:100]}...\\n**Status:** {status} ({product['stock']} units available)\",\n                inline=False\n            )\n            if product.get('image_url'):\n                embed.set_thumbnail(url=product['image_url'])\n        \n        embed.set_footer(text=\"üí° Click 'Buy' button below to purchase your product\")\n        \n        view = ProductView(products)\n        await interaction.followup.send(embed=embed, view=view, ephemeral=True)\n\nclass StockView(ui.View):\n    def __init__(self):\n        super().__init__(timeout=None)\n\n    @ui.button(label=\"Show Stock\", style=discord.ButtonStyle.primary, custom_id=\"show_stock\")\n    async def show_stock(self, interaction: discord.Interaction, button: ui.Button):\n        view = ui.View()\n        view.add_item(CategorySelect())\n        await interaction.response.send_message(\n            \"Please select a category below to view products:\",\n            view=view,\n            ephemeral=True\n        )\n\nclass BuyModal(ui.Modal):\n    def __init__(self, product: dict):\n        super().__init__(title=f\"Purchase {product['name']}\")\n        self.product = product\n        \n        self.quantity = ui.TextInput(\n            label=\"Quantity\",\n            placeholder=\"Enter quantity (1-100)\",\n            min_length=1,\n            max_length=3,\n            required=True\n        )\n        self.add_item(self.quantity)\n        \n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            quantity = int(self.quantity.value)\n            if quantity < 1 or quantity > 100:\n                raise ValueError(\"Invalid quantity\")\n                \n            if quantity > self.product['stock']:\n                await interaction.response.send_message(\n                    \"Sorry, not enough stock available.\",\n                    ephemeral=True\n                )\n                return\n                \n            view = PaymentMethodView(self.product, quantity)\n            await interaction.response.send_message(\n                \"Please select your payment method:\",\n                view=view,\n                ephemeral=True\n            )\n            \n        except ValueError:\n            await interaction.response.send_message(\n                \"Please enter a valid quantity between 1 and 100.\",\n                ephemeral=True\n            )\n\nclass PaymentMethodView(ui.View):\n    def __init__(self, product: dict, quantity: int):\n        super().__init__(timeout=300)\n        self.product = product\n        self.quantity = quantity\n        self.total = product['price'] * quantity\n\n    async def handle_payment_selection(self, interaction: discord.Interaction, payment_method: str):\n        from database.db_manager import DatabaseManager\n        import random\n        import string\n        from datetime import datetime\n        \n        db = DatabaseManager(os.getenv('DATABASE_PATH'))\n        \n        date = datetime.now().strftime(\"%Y%m%d\")\n        random_chars = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))\n        order_id = f\"NC-{date}-{random_chars}\"\n        \n        success = await db.create_order(\n            order_id=order_id,\n            user_id=str(interaction.user.id),\n            product_id=self.product['id'],\n            quantity=self.quantity,\n            total_price=self.total,\n            payment_method=payment_method\n        )\n        \n        if not success:\n            await interaction.response.send_message(\n                \"‚ùå Failed to create order. Please try again.\",\n                ephemeral=True\n            )\n            return\n        \n        embed = discord.Embed(\n            title=\"üõçÔ∏è Order Created Successfully\",\n            description=f\"Order ID: **{order_id}**\",\n            color=0x8b5cf6\n        )\n        \n        embed.add_field(name=\"Product\", value=self.product['name'], inline=True)\n        embed.add_field(name=\"Quantity\", value=str(self.quantity), inline=True)\n        embed.add_field(name=\"Total\", value=f\"‚Ç¨{self.total:.2f}\", inline=True)\n        \n        if payment_method == 'paypal':\n            embed.add_field(\n                name=\"üí≥ PayPal Payment Instructions\",\n                value=f\"\"\"\n                Please send **‚Ç¨{self.total:.2f}** to:\n                **PayPal:** {os.getenv('PAYPAL_EMAIL')}\n                \n                **Important:**\n                ‚Ä¢ Send as Friends & Family\n                ‚Ä¢ Include Order ID (**{order_id}**) in the payment notes\n                ‚Ä¢ After payment, send proof of payment so our staff can review your order\n                \"\"\",\n                inline=False\n            )\n        else:\n            address_var = f\"{payment_method.upper()}_ADDRESS\"\n            address = os.getenv(address_var, \"Contact staff for address\")\n            \n            network_info = \"\"\n            if payment_method == 'usdt':\n                network_info = \"\\n**Network:** Tron (TRC20)\"\n            \n            embed.add_field(\n                name=f\"üí∞ {payment_method.upper()} Payment Instructions\",\n                value=f\"\"\"\n                Please send **‚Ç¨{self.total:.2f}** worth of {payment_method.upper()} to:\n                **Address:** `{address}`{network_info}\n                \n                **Important:**\n                ‚Ä¢ Include Order ID (**{order_id}**) in transaction notes if possible\n                ‚Ä¢ After payment, send proof of payment so our staff can review your order\n                \"\"\",\n                inline=False\n            )\n        \n        embed.set_footer(text=\"Send proof of payment so our staff can review your order\")\n        embed.timestamp = discord.utils.utcnow()\n        \n        try:\n            await interaction.user.send(embed=embed)\n            await interaction.response.send_message(\n                \"‚úÖ Order created! Check your DMs for payment instructions.\",\n                ephemeral=True\n            )\n        except discord.Forbidden:\n            await interaction.response.send_message(\n                \"‚ùå I couldn't send you a DM. Please enable DMs from server members and try again.\",\n                ephemeral=True\n            )\n\n    @ui.button(label=\"PayPal\", style=discord.ButtonStyle.primary, emoji=\"üí≥\")\n    async def paypal(self, interaction: discord.Interaction, button: ui.Button):\n        await self.handle_payment_selection(interaction, \"paypal\")\n\n    @ui.button(label=\"Crypto\", style=discord.ButtonStyle.primary, emoji=\"üí∞\")\n    async def crypto(self, interaction: discord.Interaction, button: ui.Button):\n        view = CryptoSelectView(self.product, self.quantity, self.total)\n        await interaction.response.send_message(\n            \"Select cryptocurrency:\",\n            view=view,\n            ephemeral=True\n        )\n\nclass CryptoSelectView(ui.View):\n    def __init__(self, product: dict, quantity: int, total: float):\n        super().__init__(timeout=300)\n        self.product = product\n        self.quantity = quantity\n        self.total = total\n\n    async def handle_payment_selection(self, interaction: discord.Interaction, payment_method: str):\n        payment_view = PaymentMethodView(self.product, self.quantity)\n        await payment_view.handle_payment_selection(interaction, payment_method)\n\n    @ui.select(\n        placeholder=\"Select cryptocurrency...\",\n        options=[\n            discord.SelectOption(value=\"btc\", label=\"Bitcoin\", emoji=\"ü™ô\"),\n            discord.SelectOption(value=\"eth\", label=\"Ethereum\", emoji=\"üíé\"),\n            discord.SelectOption(value=\"ltc\", label=\"Litecoin\", emoji=\"üî∑\"),\n            discord.SelectOption(value=\"usdt\", label=\"USDT\", emoji=\"üíµ\"),\n            discord.SelectOption(value=\"sol\", label=\"Solana\", emoji=\"‚òÄÔ∏è\"),\n        ]\n    )\n    async def crypto_select(self, interaction: discord.Interaction, select: ui.Select):\n        await self.handle_payment_selection(interaction, select.values[0])\n\nclass ProductView(ui.View):\n    def __init__(self, products: List[dict]):\n        super().__init__(timeout=300)\n        self.products = {p['name']: p for p in products}\n        \n        for product in products:\n            button = ui.Button(\n                label=f\"Buy {product['name']}\",\n                style=discord.ButtonStyle.success,\n                custom_id=f\"buy_{product['name']}\"\n            )\n            button.callback = lambda i, p=product: self.buy_callback(i, p)\n            self.add_item(button)\n            \n    async def buy_callback(self, interaction: discord.Interaction, product: dict):\n        if product['stock'] <= 0:\n            await interaction.response.send_message(\n                \"Sorry, this product is out of stock.\",\n                ephemeral=True\n            )\n            return\n            \n        modal = BuyModal(product)\n        await interaction.response.send_modal(modal)\n","size_bytes":10643},"database/db_manager.py":{"content":"import aiosqlite\r\nimport os\r\nimport logging\r\nfrom datetime import datetime\r\nfrom typing import Dict, List, Optional, Tuple\r\n\r\nclass DatabaseManager:\r\n    def __init__(self, db_path: str):\r\n        self.db_path = db_path\r\n\r\n    async def init_db(self):\r\n        \"\"\"Initialize database tables\"\"\"\r\n        async with aiosqlite.connect(self.db_path) as db:\r\n            # Products table\r\n            await db.execute('''\r\n                CREATE TABLE IF NOT EXISTS products (\r\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                    name TEXT UNIQUE NOT NULL,\r\n                    category TEXT NOT NULL,\r\n                    description TEXT,\r\n                    price REAL NOT NULL,\r\n                    stock INTEGER NOT NULL,\r\n                    image_url TEXT,\r\n                    deliverables TEXT,\r\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                    is_deleted BOOLEAN DEFAULT FALSE\r\n                )\r\n            ''')\r\n            \r\n            # Initialize test products\r\n            test_products = [\r\n                # Best Sold Category\r\n                {\r\n                    \"name\": \"‚≠ê Premium Discord Nitro\",\r\n                    \"category\": \"best_sold\",\r\n                    \"description\": \"1 Year Discord Nitro subscription with instant delivery. Most popular choice!\",\r\n                    \"price\": 49.99,\r\n                    \"stock\": 15,\r\n                    \"image_url\": \"https://i.imgur.com/nitro_premium.png\",\r\n                    \"deliverables\": \"1x Discord Nitro Gift Link,Instructions for activation\"\r\n                },\r\n                # New Category\r\n                {\r\n                    \"name\": \"üÜï Spotify Premium Family\",\r\n                    \"category\": \"new\",\r\n                    \"description\": \"6 Months Spotify Premium Family Plan. Add up to 6 members!\",\r\n                    \"price\": 29.99,\r\n                    \"stock\": 10,\r\n                    \"image_url\": \"https://i.imgur.com/spotify_premium.png\",\r\n                    \"deliverables\": \"Account credentials,Activation guide,Support for 6 months\"\r\n                },\r\n                # Social Media Boost Category\r\n                {\r\n                    \"name\": \"üìà Instagram Growth Package\",\r\n                    \"category\": \"social\",\r\n                    \"description\": \"Premium Instagram growth package: 5000 followers, 10000 likes, 100 comments\",\r\n                    \"price\": 39.99,\r\n                    \"stock\": 20,\r\n                    \"image_url\": \"https://i.imgur.com/instagram_boost.png\",\r\n                    \"deliverables\": \"Service activation within 24h,Progress tracking link\"\r\n                },\r\n                {\r\n                    \"name\": \"üöÄ TikTok Viral Package\",\r\n                    \"category\": \"social\",\r\n                    \"description\": \"Go viral: 100k views, 10k likes, 500 shares for your TikTok video\",\r\n                    \"price\": 24.99,\r\n                    \"stock\": 25,\r\n                    \"image_url\": \"https://i.imgur.com/tiktok_boost.png\",\r\n                    \"deliverables\": \"Service activation code,Instructions PDF\"\r\n                },\r\n                # Discord Category\r\n                {\r\n                    \"name\": \"ü§ñ Custom Discord Bot\",\r\n                    \"category\": \"discord\",\r\n                    \"description\": \"Custom Discord bot development with your requested features\",\r\n                    \"price\": 99.99,\r\n                    \"stock\": 5,\r\n                    \"image_url\": \"https://i.imgur.com/discord_bot.png\",\r\n                    \"deliverables\": \"Source code,Setup guide,1 month support\"\r\n                },\r\n                # Accounts Category\r\n                {\r\n                    \"name\": \"üéÆ Netflix Premium 4K\",\r\n                    \"category\": \"accounts\",\r\n                    \"description\": \"Netflix Premium 4K UHD account - 1 year warranty\",\r\n                    \"price\": 34.99,\r\n                    \"stock\": 30,\r\n                    \"image_url\": \"https://i.imgur.com/netflix_premium.png\",\r\n                    \"deliverables\": \"Account credentials,Warranty information\"\r\n                },\r\n                # Services Category\r\n                {\r\n                    \"name\": \"üíª Website Development\",\r\n                    \"category\": \"services\",\r\n                    \"description\": \"Professional website development with modern design\",\r\n                    \"price\": 199.99,\r\n                    \"stock\": 3,\r\n                    \"image_url\": \"https://i.imgur.com/web_dev.png\",\r\n                    \"deliverables\": \"Website files,Domain setup,SEO optimization\"\r\n                }\r\n            ]\r\n\r\n            for product in test_products:\r\n                await db.execute('''\r\n                    INSERT OR REPLACE INTO products \r\n                    (name, category, description, price, stock, image_url, deliverables)\r\n                    VALUES (?, ?, ?, ?, ?, ?, ?)\r\n                ''', (\r\n                    product[\"name\"],\r\n                    product[\"category\"],\r\n                    product[\"description\"],\r\n                    product[\"price\"],\r\n                    product[\"stock\"],\r\n                    product[\"image_url\"],\r\n                    product[\"deliverables\"]\r\n                ))\r\n\r\n            # Orders table\r\n            await db.execute('''\r\n                CREATE TABLE IF NOT EXISTS orders (\r\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                    order_id TEXT UNIQUE NOT NULL,\r\n                    user_id TEXT NOT NULL,\r\n                    product_id INTEGER NOT NULL,\r\n                    quantity INTEGER NOT NULL,\r\n                    total_price REAL NOT NULL,\r\n                    payment_method TEXT NOT NULL,\r\n                    status TEXT NOT NULL,\r\n                    proof_image TEXT,\r\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                    FOREIGN KEY (product_id) REFERENCES products (id)\r\n                )\r\n            ''')\r\n\r\n            # Sales stats table\r\n            await db.execute('''\r\n                CREATE TABLE IF NOT EXISTS sales_stats (\r\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                    date DATE NOT NULL,\r\n                    product_id INTEGER NOT NULL,\r\n                    quantity_sold INTEGER NOT NULL,\r\n                    revenue REAL NOT NULL,\r\n                    FOREIGN KEY (product_id) REFERENCES products (id)\r\n                )\r\n            ''')\r\n\r\n            # Blacklist table\r\n            await db.execute('''\r\n                CREATE TABLE IF NOT EXISTS blacklist (\r\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                    user_id TEXT UNIQUE NOT NULL,\r\n                    reason TEXT,\r\n                    added_by TEXT NOT NULL,\r\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n                )\r\n            ''')\r\n\r\n            await db.commit()\r\n\r\n    async def add_product(self, name: str, category: str, price: float, description: str,\r\n                         image_url: str, deliverables: str, stock: int = 0) -> bool:\r\n        \"\"\"Add a new product or update existing one\"\"\"\r\n        try:\r\n            async with aiosqlite.connect(self.db_path) as db:\r\n                await db.execute('''\r\n                    INSERT INTO products (name, category, price, description, image_url, deliverables, stock)\r\n                    VALUES (?, ?, ?, ?, ?, ?, ?)\r\n                    ON CONFLICT(name) DO UPDATE SET\r\n                        category=excluded.category,\r\n                        price=excluded.price,\r\n                        description=excluded.description,\r\n                        image_url=excluded.image_url,\r\n                        deliverables=excluded.deliverables,\r\n                        stock=excluded.stock,\r\n                        updated_at=CURRENT_TIMESTAMP\r\n                ''', (name, category, price, description, image_url, deliverables, stock))\r\n                await db.commit()\r\n                return True\r\n        except Exception as e:\r\n            logging.error(f\"Error adding/updating product: {str(e)}\")\r\n            return False\r\n\r\n    async def get_products_by_category(self, category: str) -> List[Dict]:\r\n        \"\"\"Get all products in a category\"\"\"\r\n        async with aiosqlite.connect(self.db_path) as db:\r\n            db.row_factory = aiosqlite.Row\r\n            cursor = await db.execute('''\r\n                SELECT * FROM products \r\n                WHERE category = ? AND is_deleted = FALSE \r\n                ORDER BY created_at DESC\r\n            ''', (category,))\r\n            rows = await cursor.fetchall()\r\n            return [dict(row) for row in rows]\r\n\r\n    async def create_order(self, order_id: str, user_id: str, product_id: int,\r\n                          quantity: int, total_price: float, payment_method: str) -> bool:\r\n        \"\"\"Create a new order\"\"\"\r\n        try:\r\n            async with aiosqlite.connect(self.db_path) as db:\r\n                await db.execute('''\r\n                    INSERT INTO orders (order_id, user_id, product_id, quantity,\r\n                                      total_price, payment_method, status)\r\n                    VALUES (?, ?, ?, ?, ?, ?, 'pending_proof')\r\n                ''', (order_id, user_id, product_id, quantity, total_price, payment_method))\r\n                await db.commit()\r\n                return True\r\n        except Exception as e:\r\n            logging.error(f\"Error creating order: {str(e)}\")\r\n            return False\r\n\r\n    async def update_order_status(self, order_id: str, status: str) -> bool:\r\n        \"\"\"Update order status and handle stock/stats updates\"\"\"\r\n        async with aiosqlite.connect(self.db_path) as db:\r\n            await db.execute('BEGIN TRANSACTION')\r\n            try:\r\n                # Update order status\r\n                cursor = await db.execute('''\r\n                    UPDATE orders SET status = ?, updated_at = CURRENT_TIMESTAMP\r\n                    WHERE order_id = ? RETURNING product_id, quantity, total_price\r\n                ''', (status, order_id))\r\n                row = await cursor.fetchone()\r\n                \r\n                if not row:\r\n                    raise Exception(\"Order not found\")\r\n                \r\n                product_id, quantity, total_price = row\r\n                \r\n                if status == 'completed':\r\n                    # Update product stock\r\n                    cursor = await db.execute('''\r\n                        UPDATE products \r\n                        SET stock = stock - ?,\r\n                            updated_at = CURRENT_TIMESTAMP\r\n                        WHERE id = ? AND stock >= ?\r\n                        RETURNING stock\r\n                    ''', (quantity, product_id, quantity))\r\n                    \r\n                    stock_row = await cursor.fetchone()\r\n                    if not stock_row:\r\n                        raise Exception(\"Insufficient stock\")\r\n                    \r\n                    # Update sales stats\r\n                    await db.execute('''\r\n                        INSERT INTO sales_stats (date, product_id, quantity_sold, revenue)\r\n                        VALUES (date('now'), ?, ?, ?)\r\n                    ''', (product_id, quantity, total_price))\r\n                \r\n                await db.commit()\r\n                return True\r\n                \r\n            except Exception as e:\r\n                await db.execute('ROLLBACK')\r\n                logging.error(f\"Error updating order: {str(e)}\")\r\n                return False\r\n\r\n    async def get_sales_stats(self, period: str = 'all') -> Tuple[Dict, List[Dict]]:\r\n        \"\"\"Get sales statistics for the specified period\"\"\"\r\n        date_filter = {\r\n            'daily': 'date = date(\"now\")',\r\n            'weekly': 'date >= date(\"now\", \"-7 days\")',\r\n            'monthly': 'date >= date(\"now\", \"-30 days\")',\r\n            'all': '1=1'\r\n        }.get(period, '1=1')\r\n\r\n        async with aiosqlite.connect(self.db_path) as db:\r\n            db.row_factory = aiosqlite.Row\r\n            \r\n            # Get summary stats\r\n            cursor = await db.execute(f'''\r\n                SELECT \r\n                    COUNT(DISTINCT o.id) as total_orders,\r\n                    COUNT(DISTINCT CASE WHEN o.status = 'completed' THEN o.id END) as completed_orders,\r\n                    SUM(CASE WHEN o.status = 'completed' THEN o.total_price END) as total_revenue\r\n                FROM orders o\r\n                WHERE {date_filter}\r\n            ''')\r\n            summary = dict(await cursor.fetchone())\r\n            \r\n            # Get best-selling products\r\n            cursor = await db.execute(f'''\r\n                SELECT \r\n                    p.name,\r\n                    COUNT(o.id) as orders,\r\n                    SUM(o.quantity) as units_sold,\r\n                    SUM(o.total_price) as revenue\r\n                FROM products p\r\n                JOIN orders o ON p.id = o.product_id\r\n                WHERE o.status = 'completed' AND {date_filter}\r\n                GROUP BY p.id\r\n                ORDER BY revenue DESC\r\n                LIMIT 5\r\n            ''')\r\n            best_sellers = [dict(row) for row in cursor]\r\n            \r\n            return summary, best_sellers\n    async def get_pending_order(self, user_id: str) -> Optional[Dict]:\n        \"\"\"Get pending order for a user\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            db.row_factory = aiosqlite.Row\n            cursor = await db.execute('''\n                SELECT * FROM orders \n                WHERE user_id = ? AND status = 'pending_proof'\n                ORDER BY created_at DESC\n                LIMIT 1\n            ''', (user_id,))\n            row = await cursor.fetchone()\n            return dict(row) if row else None\n    \n    async def get_product(self, product_id: int) -> Optional[Dict]:\n        \"\"\"Get a product by ID\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            db.row_factory = aiosqlite.Row\n            cursor = await db.execute('''\n                SELECT * FROM products WHERE id = ?\n            ''', (product_id,))\n            row = await cursor.fetchone()\n            return dict(row) if row else None\n    \n    async def update_order_proof(self, order_id: str, proof_url: str) -> bool:\n        \"\"\"Update order with payment proof\"\"\"\n        try:\n            async with aiosqlite.connect(self.db_path) as db:\n                await db.execute('''\n                    UPDATE orders \n                    SET proof_image = ?, updated_at = CURRENT_TIMESTAMP\n                    WHERE order_id = ?\n                ''', (proof_url, order_id))\n                await db.commit()\n                return True\n        except Exception as e:\n            logging.error(f\"Error updating order proof: {str(e)}\")\n            return False\n\n    async def get_order_by_id(self, order_id: str) -> Optional[Dict]:\n        \"\"\"Get order details by order ID\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            db.row_factory = aiosqlite.Row\n            cursor = await db.execute('''\n                SELECT o.*, p.name as product_name, p.category as product_category\n                FROM orders o\n                LEFT JOIN products p ON o.product_id = p.id\n                WHERE o.order_id = ?\n            ''', (order_id,))\n            row = await cursor.fetchone()\n            return dict(row) if row else None\n","size_bytes":15513},"cogs/__init__.py":{"content":"","size_bytes":0},"pyproject.toml":{"content":"[project]\nname = \"python-template\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\nrequires-python = \">=3.11\"\ndependencies = []\n","size_bytes":157},"cogs/order_management.py":{"content":"import discord\nfrom discord.ext import commands\nimport os\nimport logging\nfrom datetime import datetime\nimport random\nimport string\nfrom typing import Optional\nfrom database.db_manager import DatabaseManager\nfrom utils.deliverables_helper import format_deliverables\n\nclass OrderManagement(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.db = DatabaseManager(os.getenv('DATABASE_PATH'))\n        self._staff_role_ids = set(map(int, os.getenv('STAFF_ROLE_IDS').split(',')))\n        self._customer_role_id = int(os.getenv('CUSTOMER_ROLE_ID'))\n        self._public_log_channel = int(os.getenv('PUBLIC_LOG_CHANNEL_ID'))\n        \n    def is_staff(self, member: discord.Member) -> bool:\n        \"\"\"Check if member has staff role\"\"\"\n        return any(role.id in self._staff_role_ids for role in member.roles)\n\n    def generate_order_id(self) -> str:\n        \"\"\"Generate unique order ID\"\"\"\n        date = datetime.now().strftime(\"%Y%m%d\")\n        random_chars = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))\n        return f\"NC-{date}-{random_chars}\"\n\n    async def create_payment_embed(self, user: discord.User, order: dict, product: dict) -> discord.Embed:\n        \"\"\"Create payment instructions embed\"\"\"\n        embed = discord.Embed(\n            title=\"üõçÔ∏è Order Details\",\n            description=f\"Order ID: {order['order_id']}\",\n            color=0x8b5cf6\n        )\n        \n        total = order['total_price']\n        embed.add_field(name=\"Product\", value=product['name'], inline=True)\n        embed.add_field(name=\"Quantity\", value=str(order['quantity']), inline=True)\n        embed.add_field(name=\"Total\", value=f\"‚Ç¨{total:.2f}\", inline=True)\n        \n        if order['payment_method'] == 'paypal':\n            embed.add_field(\n                name=\"Payment Instructions\",\n                value=f\"\"\"\n                Please send ‚Ç¨{total:.2f} to:\n                PayPal: {os.getenv('PAYPAL_EMAIL')}\n                \n                Important:\n                ‚Ä¢ Send as Friends & Family\n                ‚Ä¢ Include Order ID ({order['order_id']}) in notes\n                \"\"\",\n                inline=False\n            )\n        else:\n            address_var = f\"{order['payment_method'].upper()}_ADDRESS\"\n            address = os.getenv(address_var)\n            \n            network = \"\"\n            if order['payment_method'] == 'usdt':\n                network = \"\\nNetwork: Tron (TRC20)\"\n            \n            embed.add_field(\n                name=\"Payment Instructions\",\n                value=f\"\"\"\n                Please send ‚Ç¨{total:.2f} worth of {order['payment_method'].upper()} to:\n                Address: `{address}`{network}\n                \"\"\",\n                inline=False\n            )\n            \n        embed.add_field(\n            name=\"üìé Upload Payment Proof\",\n            value=\"Please upload your payment screenshot/proof as a reply to this message.\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"¬© NovaCore ‚Ä¢ All Rights Reserved\")\n        return embed\n\n    async def send_staff_review(self, order: dict, product: dict,\n                              proof_url: str, user: discord.User):\n        \"\"\"Send payment proof to staff for review\"\"\"\n        staff_channel = self.bot.get_channel(int(os.getenv('STAFF_CHANNEL_ID')))\n        if not staff_channel:\n            logging.error(\"Staff channel not found\")\n            return\n            \n        embed = discord.Embed(\n            title=\"üí∏ Payment Proof Received\",\n            color=0x8b5cf6\n        )\n        \n        embed.add_field(name=\"Order\", value=order['order_id'], inline=True)\n        embed.add_field(name=\"Product\", value=product['name'], inline=True)\n        embed.add_field(name=\"Quantity\", value=str(order['quantity']), inline=True)\n        embed.add_field(name=\"Amount\", value=f\"‚Ç¨{order['total_price']:.2f}\", inline=True)\n        embed.add_field(name=\"Payment Method\", value=order['payment_method'].upper(), inline=True)\n        embed.add_field(name=\"Buyer\", value=user.mention, inline=True)\n        \n        if proof_url:\n            embed.set_image(url=proof_url)\n            \n        view = ReviewView(self.bot, order['order_id'], product, user.id, order['quantity'], self._staff_role_ids)\n        await staff_channel.send(embed=embed, view=view)\n\n    @discord.app_commands.command(name=\"details\")\n    @discord.app_commands.describe(order_id=\"Order ID to view details\")\n    async def details(self, interaction: discord.Interaction, order_id: str):\n        \"\"\"View details of a specific order\"\"\"\n        if not self.is_staff(interaction.user):\n            await interaction.response.send_message(\n                \"You don't have permission to use this command.\",\n                ephemeral=True\n            )\n            return\n\n        order = await self.db.get_order_by_id(order_id)\n        if not order:\n            await interaction.response.send_message(\n                f\"‚ùå Order `{order_id}` not found.\",\n                ephemeral=True\n            )\n            return\n\n        status_emoji = {\n            'pending_proof': '‚è≥',\n            'completed': '‚úÖ',\n            'rejected': '‚ùå',\n            'cancelled': 'üö´'\n        }.get(order['status'], '‚ùì')\n\n        status_color = {\n            'pending_proof': 0xFFA500,\n            'completed': 0x00FF00,\n            'rejected': 0xFF0000,\n            'cancelled': 0x808080\n        }.get(order['status'], 0x8b5cf6)\n\n        embed = discord.Embed(\n            title=f\"{status_emoji} Order Details\",\n            description=f\"**Order ID:** `{order['order_id']}`\",\n            color=status_color\n        )\n\n        embed.add_field(\n            name=\"üì¶ Product\",\n            value=order.get('product_name', 'Unknown'),\n            inline=True\n        )\n        embed.add_field(\n            name=\"üìä Quantity\",\n            value=f\"x{order['quantity']}\",\n            inline=True\n        )\n        embed.add_field(\n            name=\"üí∞ Total\",\n            value=f\"‚Ç¨{order['total_price']:.2f}\",\n            inline=True\n        )\n        embed.add_field(\n            name=\"üí≥ Payment Method\",\n            value=order['payment_method'].upper(),\n            inline=True\n        )\n        embed.add_field(\n            name=\"üìã Status\",\n            value=order['status'].replace('_', ' ').title(),\n            inline=True\n        )\n        embed.add_field(\n            name=\"üë§ User ID\",\n            value=f\"`{order['user_id']}`\",\n            inline=True\n        )\n        embed.add_field(\n            name=\"üìÖ Created At\",\n            value=f\"<t:{int(datetime.fromisoformat(order['created_at']).timestamp())}:F>\",\n            inline=False\n        )\n\n        if order.get('proof_image'):\n            embed.set_image(url=order['proof_image'])\n            embed.add_field(\n                name=\"üñºÔ∏è Payment Proof\",\n                value=\"See image below\",\n                inline=False\n            )\n\n        embed.set_footer(text=f\"Requested by {interaction.user.name}\")\n        embed.timestamp = discord.utils.utcnow()\n\n        await interaction.response.send_message(embed=embed)\n\n    @commands.Cog.listener()\n    async def on_message(self, message: discord.Message):\n        \"\"\"Handle payment proof uploads in DMs\"\"\"\n        if message.author.bot or not isinstance(message.channel, discord.DMChannel):\n            return\n            \n        order = await self.db.get_pending_order(str(message.author.id))\n        if not order:\n            return\n            \n        if not message.attachments:\n            await message.channel.send(\n                \"Please upload an image as payment proof.\"\n            )\n            return\n        \n        is_image = False\n        for att in message.attachments:\n            if att.content_type and att.content_type.startswith('image/'):\n                is_image = True\n                break\n            elif att.filename and att.filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.webp')):\n                is_image = True\n                break\n        \n        if not is_image:\n            await message.channel.send(\n                \"Please upload an image as payment proof.\"\n            )\n            return\n            \n        proof_url = message.attachments[0].url\n        \n        product = await self.db.get_product(order['product_id'])\n        if not product:\n            await message.channel.send(\n                \"Error: Product not found. Please contact support.\"\n            )\n            return\n            \n        success = await self.db.update_order_proof(\n            order['order_id'],\n            proof_url\n        )\n        \n        if success:\n            await message.channel.send(\n                \"‚úÖ Payment proof received! Staff will review it shortly.\"\n            )\n            await self.send_staff_review(\n                order, product, proof_url, message.author\n            )\n        else:\n            await message.channel.send(\n                \"Error saving payment proof. Please try again or contact support.\"\n            )\n\nclass ReviewView(discord.ui.View):\n    def __init__(self, bot, order_id: str, product: dict, user_id: int, quantity: int, staff_role_ids: set):\n        super().__init__(timeout=None)\n        self.bot = bot\n        self.order_id = order_id\n        self.product = product\n        self.user_id = user_id\n        self.quantity = quantity\n        self._staff_role_ids = staff_role_ids\n        self.db = DatabaseManager(os.getenv('DATABASE_PATH'))\n\n    @discord.ui.button(label=\"‚úÖ Accept Payment\",\n                      style=discord.ButtonStyle.green,\n                      custom_id=\"accept_payment\")\n    async def accept_payment(self,\n                           interaction: discord.Interaction,\n                           button: discord.ui.Button):\n        \"\"\"Handle payment acceptance\"\"\"\n        if not any(role.id in self._staff_role_ids for role in interaction.user.roles):\n            await interaction.response.send_message(\n                \"You don't have permission to do this.\",\n                ephemeral=True\n            )\n            return\n\n        await interaction.response.defer()\n\n        success = await self.db.update_order_status(self.order_id, 'completed')\n        if not success:\n            await interaction.followup.send(\n                \"Error updating order status. Please try again.\",\n                ephemeral=True\n            )\n            return\n\n        try:\n            user = self.bot.get_user(self.user_id)\n            if user:\n                embed = discord.Embed(\n                    title=\"üéâ Order Completed Successfully!\",\n                    description=f\"**Order ID:** `{self.order_id}`\\n\\nThank you for your purchase! Your order has been approved and completed.\",\n                    color=0x00ff00\n                )\n                \n                deliverables_str = self.product.get('deliverables', '')\n                formatted_deliverables = format_deliverables(deliverables_str)\n                \n                embed.add_field(\n                    name=\"üì¶ What You Get\",\n                    value=formatted_deliverables,\n                    inline=False\n                )\n                \n                embed.add_field(\n                    name=\"üí¨ Leave a Vouch!\",\n                    value=\"If you're happy with your purchase, please leave a vouch in <#1434532909548572792>!\\n\\n**Your feedback helps us grow!** ‚≠ê\",\n                    inline=False\n                )\n                \n                embed.set_footer(text=\"¬© NovaCore ‚Ä¢ Thank you for your business!\", icon_url=\"https://i.imgur.com/OpQROuS.png\")\n                embed.timestamp = discord.utils.utcnow()\n                \n                await user.send(embed=embed)\n\n                guild = interaction.guild\n                member = guild.get_member(self.user_id)\n                if member:\n                    role = guild.get_role(int(os.getenv('CUSTOMER_ROLE_ID')))\n                    if role and role not in member.roles:\n                        await member.add_roles(role)\n\n            public_channel = self.bot.get_channel(\n                int(os.getenv('PUBLIC_LOG_CHANNEL_ID'))\n            )\n            if public_channel:\n                embed = discord.Embed(\n                    title=\"üõçÔ∏è New Purchase!\",\n                    description=f\"A customer just purchased from our store!\",\n                    color=0x8b5cf6\n                )\n                embed.add_field(\n                    name=\"üì¶ Product\",\n                    value=f\"**{self.product['name']}**\",\n                    inline=True\n                )\n                embed.add_field(\n                    name=\"üìä Quantity\",\n                    value=f\"**x{self.quantity}**\",\n                    inline=True\n                )\n                embed.add_field(\n                    name=\"üí∞ Value\",\n                    value=f\"**‚Ç¨{self.product['price'] * self.quantity:.2f}**\",\n                    inline=True\n                )\n                embed.set_footer(text=\"¬© NovaCore ‚Ä¢ Your trusted marketplace\", icon_url=\"https://i.imgur.com/OpQROuS.png\")\n                embed.timestamp = discord.utils.utcnow()\n                await public_channel.send(embed=embed)\n\n            for child in self.children:\n                child.disabled = True\n            await interaction.message.edit(view=self)\n\n            await interaction.followup.send(\n                \"‚úÖ Order completed successfully!\",\n                ephemeral=True\n            )\n\n        except Exception as e:\n            logging.error(f\"Error completing order: {str(e)}\")\n            await interaction.followup.send(\n                \"Error completing order. Some actions may have failed.\",\n                ephemeral=True\n            )\n\n    @discord.ui.button(label=\"‚ùå Reject Payment\",\n                      style=discord.ButtonStyle.red,\n                      custom_id=\"reject_payment\")\n    async def reject_payment(self,\n                           interaction: discord.Interaction,\n                           button: discord.ui.Button):\n        \"\"\"Handle payment rejection\"\"\"\n        if not any(role.id in self._staff_role_ids for role in interaction.user.roles):\n            await interaction.response.send_message(\n                \"You don't have permission to do this.\",\n                ephemeral=True\n            )\n            return\n\n        modal = RejectModal(self.order_id, self.user_id, self.db)\n        await interaction.response.send_modal(modal)\n\nclass RejectModal(discord.ui.Modal):\n    def __init__(self, order_id: str, user_id: int, db: DatabaseManager):\n        super().__init__(title=\"Reject Payment\")\n        self.order_id = order_id\n        self.user_id = user_id\n        self.db = db\n        \n        self.reason = discord.ui.TextInput(\n            label=\"Rejection Reason\",\n            placeholder=\"Enter reason for rejection\",\n            required=True,\n            max_length=1000\n        )\n        self.add_item(self.reason)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        success = await self.db.update_order_status(self.order_id, 'rejected')\n        if not success:\n            await interaction.response.send_message(\n                \"Error updating order status. Please try again.\",\n                ephemeral=True\n            )\n            return\n\n        try:\n            user = interaction.client.get_user(self.user_id)\n            if user:\n                embed = discord.Embed(\n                    title=\"‚ùå Payment Rejected\",\n                    description=f\"Your payment for order {self.order_id} was rejected.\",\n                    color=0xff0000\n                )\n                embed.add_field(\n                    name=\"Reason\",\n                    value=self.reason.value,\n                    inline=False\n                )\n                embed.add_field(\n                    name=\"What Next?\",\n                    value=\"You can:\\n‚Ä¢ Upload a new payment proof\\n‚Ä¢ Contact support for assistance\",\n                    inline=False\n                )\n                await user.send(embed=embed)\n\n            try:\n                for child in interaction.message.view.children:\n                    child.disabled = True\n                await interaction.message.edit(view=interaction.message.view)\n            except:\n                pass\n\n            await interaction.response.send_message(\n                \"‚úÖ Payment rejected and buyer notified.\",\n                ephemeral=True\n            )\n\n        except Exception as e:\n            logging.error(f\"Error handling rejection: {str(e)}\")\n            await interaction.response.send_message(\n                \"Error handling rejection. Some actions may have failed.\",\n                ephemeral=True\n            )\n\nasync def setup(bot):\n    await bot.add_cog(OrderManagement(bot))\n","size_bytes":16871},"utils/migrate_deliverables.py":{"content":"\"\"\"\nMigration script to convert old deliverables format to new JSON format\n\nRun this once to convert all existing products from comma-separated strings\nto the new JSON format with types and emojis.\n\"\"\"\n\nimport asyncio\nimport aiosqlite\nimport json\nimport os\nimport sys\n\n# Add parent directory to path\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom database.db_manager import DatabaseManager\n\nasync def migrate_deliverables():\n    \"\"\"Migrate old deliverables to new JSON format\"\"\"\n    db_path = os.getenv('DATABASE_PATH', 'data/novacore.db')\n    \n    print(f\"üîÑ Starting migration for database: {db_path}\")\n    \n    async with aiosqlite.connect(db_path) as db:\n        db.row_factory = aiosqlite.Row\n        \n        # Get all products\n        cursor = await db.execute('SELECT id, name, deliverables FROM products')\n        products = await cursor.fetchall()\n        \n        print(f\"üì¶ Found {len(products)} products to migrate\")\n        \n        for product in products:\n            product_id = product['id']\n            name = product['name']\n            old_deliverables = product['deliverables']\n            \n            # Check if already JSON\n            try:\n                json.loads(old_deliverables)\n                print(f\"‚úÖ {name} - Already in JSON format, skipping\")\n                continue\n            except:\n                pass\n            \n            # Convert comma-separated to JSON\n            if old_deliverables:\n                items = [item.strip() for item in old_deliverables.split(',')]\n                \n                # Try to guess types based on keywords\n                new_deliverables = []\n                for item in items:\n                    item_lower = item.lower()\n                    \n                    # Guess type based on keywords\n                    if any(word in item_lower for word in ['code', 'key', 'link', 'gift']):\n                        item_type = 'code'\n                    elif any(word in item_lower for word in ['account', 'credential', 'login']):\n                        item_type = 'account'\n                    elif any(word in item_lower for word in ['file', 'source', 'website']):\n                        item_type = 'file'\n                    elif any(word in item_lower for word in ['guide', 'instruction', 'tutorial']):\n                        item_type = 'guide'\n                    elif any(word in item_lower for word in ['support', 'help', 'assistance']):\n                        item_type = 'support'\n                    elif any(word in item_lower for word in ['warranty', 'guarantee']):\n                        item_type = 'warranty'\n                    elif any(word in item_lower for word in ['service', 'activation', 'follower', 'like', 'view']):\n                        item_type = 'service'\n                    else:\n                        item_type = 'service'\n                    \n                    new_deliverables.append({\n                        \"item\": item,\n                        \"type\": item_type\n                    })\n                \n                new_json = json.dumps(new_deliverables)\n                \n                # Update database\n                await db.execute('''\n                    UPDATE products \n                    SET deliverables = ?\n                    WHERE id = ?\n                ''', (new_json, product_id))\n                \n                print(f\"‚úÖ {name}\")\n                print(f\"   Old: {old_deliverables}\")\n                print(f\"   New: {new_json}\\n\")\n        \n        await db.commit()\n        print(\"üéâ Migration completed successfully!\")\n\nif __name__ == \"__main__\":\n    asyncio.run(migrate_deliverables())\n","size_bytes":3694},"utils/product_examples.py":{"content":"\"\"\"\nExamples of how to create products with JSON deliverables\n\nThis shows the new, better format for deliverables using JSON.\nYou can use this when adding new products with /addproduct command.\n\"\"\"\n\nimport json\n\n# Simple format - just list of items\nsimple_deliverables = json.dumps([\n    \"Discord Nitro Gift Link\",\n    \"Activation instructions\",\n    \"24/7 Support\"\n])\n\n# Advanced format - with types and emojis\nadvanced_deliverables = json.dumps([\n    {\"item\": \"Discord Nitro Gift Link\", \"type\": \"code\"},\n    {\"item\": \"Activation instructions\", \"type\": \"guide\"},\n    {\"item\": \"24/7 Support\", \"type\": \"support\"}\n])\n\n# Available types and their emojis:\n# 'code' -> üîë\n# 'account' -> üë§\n# 'file' -> üìÅ\n# 'link' -> üîó\n# 'guide' -> üìñ\n# 'support' -> üí¨\n# 'service' -> ‚ö°\n# 'warranty' -> üõ°Ô∏è\n# 'key' -> üîê\n\n# Example products with new format:\n\nNITRO_DELIVERABLES = json.dumps([\n    {\"item\": \"Discord Nitro Gift Link\", \"type\": \"code\"},\n    {\"item\": \"Activation instructions\", \"type\": \"guide\"},\n    {\"item\": \"24/7 Support\", \"type\": \"support\"}\n])\n\nSPOTIFY_DELIVERABLES = json.dumps([\n    {\"item\": \"Account credentials\", \"type\": \"account\"},\n    {\"item\": \"Activation guide\", \"type\": \"guide\"},\n    {\"item\": \"6 months support\", \"type\": \"support\"}\n])\n\nINSTAGRAM_DELIVERABLES = json.dumps([\n    {\"item\": \"5000 Real Followers\", \"type\": \"service\"},\n    {\"item\": \"10000 Likes\", \"type\": \"service\"},\n    {\"item\": \"100 Comments\", \"type\": \"service\"},\n    {\"item\": \"Progress tracking link\", \"type\": \"link\"}\n])\n\nCUSTOM_BOT_DELIVERABLES = json.dumps([\n    {\"item\": \"Source code (Full access)\", \"type\": \"file\"},\n    {\"item\": \"Setup guide\", \"type\": \"guide\"},\n    {\"item\": \"1 month support\", \"type\": \"support\"},\n    {\"item\": \"Free updates for 30 days\", \"type\": \"support\"}\n])\n\nNETFLIX_DELIVERABLES = json.dumps([\n    {\"item\": \"Account credentials\", \"type\": \"account\"},\n    {\"item\": \"1 year warranty\", \"type\": \"warranty\"},\n    {\"item\": \"Replacement guarantee\", \"type\": \"support\"}\n])\n\n# When using /addproduct command, paste the JSON string as deliverables parameter\n# Example:\n# /addproduct category:best_sold product:\"Premium Service\" price:49.99 \n# description:\"Amazing service\" deliverables:'[{\"item\":\"Service key\",\"type\":\"code\"}]'\n# image_url:\"https://...\" stock:10\n\nprint(\"Product Examples with JSON Deliverables\")\nprint(\"=\"*50)\nprint(\"\\nNitro deliverables:\", NITRO_DELIVERABLES)\nprint(\"\\nSpotify deliverables:\", SPOTIFY_DELIVERABLES)\nprint(\"\\nInstagram deliverables:\", INSTAGRAM_DELIVERABLES)\n","size_bytes":2488},"main.py":{"content":"","size_bytes":0},"utils/deliverables_helper.py":{"content":"import json\nfrom typing import List, Dict, Union\n\ndef format_deliverables(deliverables: Union[str, List[Dict]]) -> str:\n    \"\"\"\n    Convert deliverables to formatted string for display\n    Supports both old format (comma-separated) and new format (JSON)\n    \"\"\"\n    if not deliverables:\n        return \"‚Ä¢ Digital product delivery\"\n    \n    # Try to parse as JSON first\n    if isinstance(deliverables, str):\n        try:\n            deliverables_list = json.loads(deliverables)\n            if isinstance(deliverables_list, list):\n                formatted = []\n                for item in deliverables_list:\n                    if isinstance(item, dict):\n                        # New format: dict with item, type, details\n                        emoji = get_type_emoji(item.get('type', ''))\n                        formatted.append(f\"{emoji} {item['item']}\")\n                    else:\n                        # Fallback for simple strings in list\n                        formatted.append(f\"‚Ä¢ {item}\")\n                return \"\\n\".join(formatted)\n        except json.JSONDecodeError:\n            # Old format: comma-separated string\n            items = deliverables.split(',')\n            return \"\\n\".join(f\"‚Ä¢ {item.strip()}\" for item in items)\n    \n    return \"‚Ä¢ Digital product delivery\"\n\ndef get_type_emoji(item_type: str) -> str:\n    \"\"\"Get emoji based on deliverable type\"\"\"\n    emoji_map = {\n        'code': 'üîë',\n        'account': 'üë§',\n        'file': 'üìÅ',\n        'link': 'üîó',\n        'guide': 'üìñ',\n        'support': 'üí¨',\n        'service': '‚ö°',\n        'warranty': 'üõ°Ô∏è',\n        'key': 'üîê'\n    }\n    return emoji_map.get(item_type.lower(), '‚úì')\n\ndef create_deliverables_json(items: List[Dict[str, str]]) -> str:\n    \"\"\"\n    Create JSON string from deliverables list\n    Example: [{\"item\": \"Code\", \"type\": \"code\"}, {\"item\": \"Guide\", \"type\": \"guide\"}]\n    \"\"\"\n    return json.dumps(items)\n\n# Example usage for new products:\nEXAMPLE_DELIVERABLES = [\n    {\"item\": \"Discord Nitro Gift Link\", \"type\": \"code\"},\n    {\"item\": \"Activation instructions\", \"type\": \"guide\"},\n    {\"item\": \"24/7 Support\", \"type\": \"support\"}\n]\n","size_bytes":2158},"replit.md":{"content":"# NovaCore Products Discord Bot\n\n## Overview\n\nNovaCore is a semi-automated Discord bot for managing a digital product shop. It handles product catalog management, automated checkout flows, payment processing (PayPal and cryptocurrency), staff review systems, and digital product delivery. The bot uses a role-based permission system to separate customer, staff, and owner capabilities, with comprehensive order tracking and sales analytics.\n\n## Recent Changes\n\n**November 2, 2025:**\n- Separated vouch and purchase notification channels: `VOUCH_CHANNEL_ID` for customer reviews/vouches, `PUBLIC_LOG_CHANNEL_ID` for purchase notifications\n- Added `/details {orderID}` command for staff to view detailed order information including status, payment proof, and timestamps\n- Fixed product image URL validation to prevent invalid thumbnail URLs in product embeds\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Bot Framework\n- **Technology**: Discord.py 2.3+ with slash commands and UI components\n- **Design Pattern**: Cog-based architecture for modular feature separation\n- **Rationale**: Discord.py provides robust async support for Discord API interactions. Cogs allow clean separation of concerns between product management, order management, and UI components.\n\n### Data Storage\n- **Database**: SQLite with aiosqlite async driver\n- **Schema Design**: \n  - Products table with soft deletes (is_deleted flag), categories, pricing, stock tracking, and deliverables\n  - Orders table (implied from code) for transaction management\n- **Rationale**: SQLite provides zero-configuration persistence suitable for Discord bots. Async operations prevent blocking the event loop during database queries.\n\n### UI Architecture\n- **Components**: Discord UI framework with Select menus, Buttons, and Modal forms\n- **Key Views**:\n  - `StockView`: Main product catalog interface\n  - `CategorySelect`: Category browsing dropdown\n  - `PaymentMethodView`: Payment selection (PayPal/Crypto)\n  - Product selection and checkout flows\n- **Rationale**: Discord's native UI components provide interactive experiences without external web interfaces, keeping everything in-platform.\n\n### Permission System\n- **Role-Based Access Control**:\n  - Customer role for buyers\n  - Staff roles for payment review and order management\n  - Owner role for product catalog management\n- **Implementation**: Environment-configured role IDs with role checking decorators\n- **Rationale**: Discord's native role system provides built-in authentication and authorization without external identity management.\n\n### Payment Processing\n- **PayPal Integration**: Manual review system where customers send payment and staff verify\n- **Cryptocurrency Support**: Multi-currency support (BTC, LTC, USDT, SOL, ETH) with manual verification\n- **Order Flow**: \n  1. Customer selects product and quantity\n  2. System generates unique order ID (NC-YYYYMMDD-XXXXXX format)\n  3. Payment instructions sent to customer\n  4. Staff review payment proof in dedicated channel\n  5. Upon approval, deliverables sent to customer\n- **Rationale**: Manual review provides fraud protection and flexibility for accepting various payment methods without automated payment gateway fees.\n\n### Product Deliverables System\n- **Format Evolution**: Migrating from comma-separated strings to JSON format with typed items\n- **Structure**: Each deliverable has an item name and type (code, account, file, link, guide, support, service, warranty, key)\n- **Display**: Type-based emoji mapping for visual clarity\n- **Migration**: Backward compatibility maintained with format detection (JSON parse fallback to CSV parsing)\n- **Rationale**: JSON format provides structured data for better extensibility and visual presentation while maintaining compatibility with existing products.\n\n### Analytics & Reporting\n- **Visualization**: Matplotlib for generating sales charts and statistics\n- **Data Export**: Pandas for data analysis capabilities\n- **Storage**: Generated images saved to configured LOG_DIR\n- **Rationale**: Embedded analytics provide actionable insights without requiring external BI tools.\n\n### Logging & Monitoring\n- **Dual Output**: File logging (novacore.log) and stdout streaming\n- **Level**: INFO level for operational visibility\n- **Structure**: Timestamp, level, and message formatting\n- **Rationale**: Comprehensive logging enables troubleshooting and operational monitoring in production environments.\n\n### Configuration Management\n- **Method**: Environment variables via python-dotenv\n- **Validation**: Startup validation ensures all required variables are present\n- **Required Variables**: \n  - Discord credentials: `DISCORD_TOKEN`\n  - Channel IDs: `MAIN_CHANNEL_ID`, `STAFF_CHANNEL_ID`, `PUBLIC_LOG_CHANNEL_ID` (for purchase logs), `VOUCH_CHANNEL_ID` (for customer reviews)\n  - Role IDs: `CUSTOMER_ROLE_ID`, `STAFF_ROLE_IDS`, `OWNER_ROLE_ID`\n  - Payment addresses: `PAYPAL_EMAIL`, `BTC_ADDRESS`, `LTC_ADDRESS`, `USDT_ADDRESS`, `SOL_ADDRESS`, `ETH_ADDRESS`\n  - Storage: `DATABASE_PATH`, `LOG_DIR`\n- **Rationale**: Environment-based configuration enables deployment flexibility and keeps secrets out of code.\n\n### File Organization\n- **Structure**:\n  - `/cogs`: Feature modules (product_management, order_management)\n  - `/database`: Data layer with DatabaseManager abstraction\n  - `/ui`: Discord UI components and views\n  - `/utils`: Helper functions, validators, migration scripts\n- **Rationale**: Modular organization supports maintainability and allows independent development of features.\n\n## External Dependencies\n\n### Discord Platform\n- **discord.py 2.3+**: Primary framework for Discord bot development\n- **Requirements**: Discord bot token, server with configured channels and roles\n- **Integration Points**: Slash commands, UI interactions, message sending, role management\n\n### Database\n- **aiosqlite**: Async SQLite driver\n- **Database File**: Configured via DATABASE_PATH environment variable\n- **Schema**: Products table with category organization and stock tracking\n\n### Payment Services\n- **PayPal**: Email-based payment collection (manual verification)\n- **Cryptocurrency**: Multi-currency wallet addresses for BTC, LTC, USDT, SOL, ETH\n- **Integration**: Manual verification workflow, no automated API integration\n\n### Python Packages\n- **matplotlib**: Chart generation for sales analytics\n- **pandas**: Data analysis and manipulation\n- **Pillow**: Image processing for proof uploads\n- **aiofiles**: Async file I/O operations\n- **python-dateutil**: Date/time manipulation utilities\n\n### File System\n- **LOG_DIR**: Storage for generated images and log files\n- **DATABASE_PATH**: SQLite database file location\n- **Requirements**: Write permissions for both directories","size_bytes":6773}},"version":2}